#!/bin/bash

# Function to get the full path of a command
get_command_path() {
  command -v $1
}

## Set the root directory in the pipeline
ROOT_DIR=$(git rev-parse --show-toplevel)
CURRENT_DIR="${PWD##*/}"

JS_APP_DIR=benefit-finder
IS_JS_APP=false
USAGOV_APP_DIR=usagov-2021

echo "Current directory ${CURRENT_DIR}"

STAGED_FILES=$(git diff-index --cached --name-only HEAD)

for file in $STAGED_FILES; do
  # Check if file is located in the JS_APP_DIR
  echo "Found staged file: $file"
  if [[ $file == *$JS_APP_DIR* ]]; then
    IS_JS_APP=true
  fi
done

# Run custom actions for our JS App
if [ $IS_JS_APP = true ]; then
    echo "Found a JS application file, running front end task(s)"
    cd $ROOT_DIR/$JS_APP_DIR && $(get_command_path npm) run lint-staged
    if [ $? -eq 0 ]; then
        echo "Process succeeded."
        cd $ROOT_DIR
    else
        echo "Process failed."
        exit 1
    fi
fi

# Check if Python 3 is installed and install if not
PYTHON3_PATH=$(get_command_path python3)
if [ -z "$PYTHON3_PATH" ]; then
    echo "Python 3 is not installed. Attempting to install Python 3..."
    $(get_command_path brew) install python3 || { echo "Failed to install Python 3. Please install it manually."; exit 1; }
    PYTHON3_PATH=$(get_command_path python3)
fi

# Check if venv module is available in Python, install if not
if ! $PYTHON3_PATH -c "import venv" &> /dev/null; then
    echo "venv module is not available. Python installation might not support venv."
    exit 1
fi

# Set up Python virtual environment
if [ ! -d ".venv" ]; then
    $PYTHON3_PATH -m venv .venv
    echo "Virtual environment created."
else
    echo "Virtual environment already exists."
fi
source .venv/bin/activate

# Check if TruffleHog3 is installed and install if not
TRUFFLEHOG3_PATH=$(get_command_path trufflehog3)
if [ -z "$TRUFFLEHOG3_PATH" ]; then
    echo "TruffleHog3 is not installed. Installing TruffleHog3..."
    $(get_command_path pip) install trufflehog3 || { echo "Failed to install TruffleHog3. Please install it manually."; exit 1; }
    TRUFFLEHOG3_PATH=$(get_command_path trufflehog3)
fi

# Check if jq is installed and install if not
JQ_PATH=$(get_command_path jq)
if [ -z "$JQ_PATH" ]; then
    echo "jq is not installed. Installing jq..."
    $(get_command_path brew) install jq || { echo "Failed to install jq. Please install it manually."; exit 1; }
    JQ_PATH=$(get_command_path jq)
fi

# Determine the branch name locally
BRANCH_NAME=$(git symbolic-ref --short HEAD)
if [ -z "$BRANCH_NAME" ]; then
    echo "Failed to determine the branch name. Ensure you are in a Git repository."
    exit 1
fi

GITIGNORE_FILE=".gitignore"
TRUFFLEHOG_CONFIG="trufflehog3.local.yml"

# Read paths from .gitignore, ignoring blank lines and comments
readarray -t gitignore_paths < <(grep -vE '^\s*(#|$)' "$GITIGNORE_FILE")

# Convert .gitignore contents to YAML for TruffleHog3
echo -e "exclude:\n  paths:" > "$TRUFFLEHOG_CONFIG"
for path in "${gitignore_paths[@]}"; do
    echo "  - $path" >> "$TRUFFLEHOG_CONFIG"
done

echo "Created $TRUFFLEHOG_CONFIG with paths from .gitignore"

TRUFFLEHOG_LOCAL_CONFIG="trufflehog3.local.yml"
TRUFFLEHOG_GLOBAL_CONFIG=".trufflehog3.yml"

# Start reading from the line where paths start
start_reading=false

while IFS= read -r line; do
    clean_line=$(echo "$line" | sed 's/^\s*//;s/\s*$//')  # Clean line from leading/trailing whitespace

    if [[ "$clean_line" == "paths:" ]]; then
        start_reading=true
        echo "  paths:" >> "$TRUFFLEHOG_LOCAL_CONFIG"  # Start the paths section in the local config
        continue
    fi

    if $start_reading; then
        if [[ "$clean_line" == "-"* ]]; then  # Check if the line is a path entry
            echo "  $clean_line" >> "$TRUFFLEHOG_LOCAL_CONFIG"  # Maintain the correct indentation
        fi
    fi

done < "$TRUFFLEHOG_GLOBAL_CONFIG"

echo "Updated paths in $TRUFFLEHOG_LOCAL_CONFIG from $TRUFFLEHOG_GLOBAL_CONFIG"

TRUFFLEHOG_LOCAL_CONFIG="trufflehog3.local.yml"

# Remove duplicate lines while preserving the order and structure
awk '!seen[$0]++' "$TRUFFLEHOG_LOCAL_CONFIG" > temp_file.yml && mv temp_file.yml "$TRUFFLEHOG_LOCAL_CONFIG"

echo "Duplicates removed from $TRUFFLEHOG_LOCAL_CONFIG"



#!/bin/bash

TRUFFLEHOG_LOCAL_CONFIG="trufflehog3.local.yml"
TEMP_FILE="temp_trufflehog3.local.yml"

# Create a temporary file for corrected lines
touch "$TEMP_FILE"

# Read each line of the configuration file
while IFS= read -r line; do
    # Check if the line contains an asterisk for wildcard patterns
    if [[ "$line" == *"*"* && ! "$line" == "**/*"* ]]; then
        # Specific pattern adjustments to ensure only incorrect patterns are changed
        corrected_line=$(echo "$line" | sed -E 's/^(\s*-\s*)\*([^*])/\1**\/\2/; s/^(\s*-\s*)\/\*([^*])/\1**\/\2/')
        echo "$corrected_line" >> "$TEMP_FILE"
    else
        # Write the line as-is if no asterisk is found or if it's already correctly formatted
        echo "$line" >> "$TEMP_FILE"
    fi
done < "$TRUFFLEHOG_LOCAL_CONFIG"

# Replace the old config file with the corrected version
mv "$TEMP_FILE" "$TRUFFLEHOG_LOCAL_CONFIG"

echo "Patterns corrected as necessary in $TRUFFLEHOG_LOCAL_CONFIG"

echo "Scanning branch: $BRANCH_NAME"

# TruffleHog3 Scan on local branch files
$TRUFFLEHOG3_PATH --no-history --no-entropy --severity MEDIUM -vv -r rules.yml --format json --output truffleHogResults.json -c $TRUFFLEHOG_LOCAL_CONFIG || true

# Prepare for result checking
# Check for secrets in the results


# Check if the results JSON file exists and is not empty
if [ -f "$ROOT_DIR/truffleHogResults.json" ]; then
    # Use jq to get the length of the content, assuming it might return a count of items or entries
    CONTENT=$($JQ_PATH 'length' "$ROOT_DIR/truffleHogResults.json")
else
    # Set CONTENT to 0 if the file does not exist or is empty to indicate no findings
    CONTENT=0
fi

# Now, use the CONTENT to determine the next steps
if [[ "$CONTENT" -eq 0 ]]; then
    # If no content is found, remove the JSON file and output that no secrets were found
    rm "$ROOT_DIR/truffleHogResults.json"
    echo "No secrets found. Commit is safe."
    exit 0
else
    # If CONTENT is not zero, indicate that secrets were detected and block the commit
    echo "Secrets detected! Commit blocked."
    echo "Please review and resolve issues."
    exit 1
fi
